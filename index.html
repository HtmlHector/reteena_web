<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Reteena - Building AI for Alzheimers Therapy and Diagnosis</title>
    <link href="./style.css" rel="stylesheet">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.svg">
</head>
<body>
    
<main>
    <div class="header">
        <h1>
            Reteena
        </h1>
        <a href="https://www.linkedin.com/company/reteena/" target="_blank">
            <svg height="24" viewBox="0 0 24 24" width="24" xmlns="file:///Users/yangseung-yong/Downloads/external-link.svg">
                <path d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zm-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93zM6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37z"
                      fill="currentColor"/>
            </svg>
        </a>
    </div>

    <section class="introduction">
        <p>
            We are building Low-Field MRI Resolution Image Enhancement Framework for Better Alzheimer's Diagnosis and
            the
            <a href="https://www.linkedin.com/posts/alexyang77_introducing-remembrance-by-reteena-the-activity-7332915036396433409-bNQ6?utm_source=share&utm_medium=member_desktop&rcm=ACoAAE3UIjQBZFtlI1COnxn2N_ig4-DZEnujWtM" target="_blank" class="external-link">
                <span style="text-decoration: underline;">LLM-based Memory Repository for Reminiscence Therapy</span>
                <svg xmlns="http://www.w3.org/2000/svg" height="14" viewBox="0 0 24 24" width="14" style="vertical-align: middle; margin-left: 4px;">
                    <path d="M18 13v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <polyline points="15 3 21 3 21 9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <line x1="10" y1="14" x2="21" y2="3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </a>
        </p>

        <p>
            Reteena shares the same pronunciation as retina, a vital part of the eye used for vision. Like the retina,
            Reteena aims to provide a new perspective on Alzheimer's.
        </p>

        <p>Founded by <a href="https://www.linkedin.com/in/alexyang77/" target="_blank">Alex</a>, <a
                href="https://www.linkedin.com/in/aarav-minocha-0828a286/" target="_blank">Aarav</a>, <a
                href="https://www.linkedin.com/in/jainish-patel-h/" target="_blank">Jainish</a>, <a
                href="https://www.linkedin.com/in/jessica-wu-817ba523b/" target="_blank">Jessica</a>, and <a
                href="https://www.linkedin.com/in/bhavya-mamnani-212a79233/" target="_blank">Bhavya</a>, with <a
                href="https://www.linkedin.com/in/sanghoo-ahn/" target="_blank">Sanghoo</a>, <a
                href="https://www.linkedin.com/in/ivanmadmv/" target="_blank">Ivan</a>, <a
                href="https://www.linkedin.com/in/olivia-jeon-6a43a52a7/" target="_blank">Olivia</a>, and <a
                href="https://www.linkedin.com/in/nathan-he-603a30255/" target="_blank">Nathan</a> later joining the
            team. </p>
    </section>

    <div id="heatmap-container" class="heatmap-container">
        <canvas id="heatmap-canvas"></canvas>
    </div>

    <section class="achievements">
        <p>We have achieved multiple milestones: submission to <a class="strong__links"
                                                               href="https://solve.mit.edu/solutions/86724"
                                                               target="_blank">MIT
            SOLVE</a>, presentation at <a class="strong__links"
                                       href="https://ieeexplore.ieee.org/document/10826144" target="_blank">IEEE
            BigData
            2024</a>, sponsorship
            from <a class="strong__links"
                  href="https://foundershub.startups.microsoft.com/" target="_blank">Microsoft Founders Hub</a>, and
            additional
            accomplishments. </p>
        <p>
            Our team will soon launch our memory repository platform in partnership with OpenNLP labs. We continuously
            experiment with innovative concepts and new ideas! Sign up below.
        </p>

        <!-- Email input system added here -->
        <div class="email-signup">
            <form id="email-form" novalidate>
                <input type="email" id="email-input" placeholder="Enter your email">
                <button type="submit" id="email-submit">Send</button>
            </form>
            <p id="email-message" class="email-message">Please enter your email address</p>
        </div>
    </section>

    <footer>
        <div class="footer_sub">
            <p>Design Inspired from linkd.inc</p>
            <p>Copyright Â© 2025 Reteena. All rights reserved.</p>
        </div>
    </footer>
</main>

<script>
    // Hide message initially
    document.getElementById('email-message').style.display = 'none';
    
    document.getElementById('email-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const emailInput = document.getElementById('email-input');
        const email = emailInput.value;
        const emailMessage = document.getElementById('email-message');
        
        if (!email) {
            // Show error message if empty
            emailInput.style.borderColor = '#ff3b30';
            emailMessage.textContent = 'Please enter your email address';
            emailMessage.style.color = '#ff3b30';
            emailMessage.style.display = 'block';
        } else {
            // Success message
            emailMessage.textContent = 'Thank you for subscribing!';
            emailMessage.style.color = '#4CAF50';
            emailMessage.style.display = 'block';
            emailInput.style.borderColor = '#e1e1e1';
            emailInput.value = '';
            // Here you would typically send this to a server
        }
    });

    // Interactive thermal heatmap visualization
    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('heatmap-canvas');
        const container = document.getElementById('heatmap-container');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Define thermal color palette
        const colorStops = [
            { pos: 0.0, r: 0, g: 0, b: 51 },      // Deep blue
            { pos: 0.3, r: 0, g: 102, b: 170 },   // Medium blue
            { pos: 0.5, r: 0, g: 170, b: 204 },   // Cyan
            { pos: 0.65, r: 0, g: 204, b: 136 },  // Teal
            { pos: 0.8, r: 119, g: 204, b: 51 },  // Green
            { pos: 0.9, r: 221, g: 204, b: 0 },   // Yellow
            { pos: 1.0, r: 255, g: 102, b: 0 }    // Orange/red
        ];
        
        // Get color from value between 0-1
        function getColor(value) {
            // Find the color stops that the value falls between
            for (let i = 0; i < colorStops.length - 1; i++) {
                if (value >= colorStops[i].pos && value <= colorStops[i+1].pos) {
                    const t = (value - colorStops[i].pos) / (colorStops[i+1].pos - colorStops[i].pos);
                    
                    // Linear interpolation between colors
                    const r = Math.round(colorStops[i].r + (colorStops[i+1].r - colorStops[i].r) * t);
                    const g = Math.round(colorStops[i].g + (colorStops[i+1].g - colorStops[i].g) * t);
                    const b = Math.round(colorStops[i].b + (colorStops[i+1].b - colorStops[i].b) * t);
                    
                    return { r, g, b };
                }
            }
            
            // Fallback to the last color
            return {
                r: colorStops[colorStops.length-1].r,
                g: colorStops[colorStops.length-1].g,
                b: colorStops[colorStops.length-1].b
            };
        }
        
        // Generate heatmap spots
        const spots = [];
        const mouseTrail = [];
        const maxTrailLength = 30;
        
        function createSpots() {
            // Clear existing spots
            spots.length = 0;
            
            // Number of heat spots depends on canvas size
            const spotCount = 8;
            
            for (let i = 0; i < spotCount; i++) {
                spots.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 30 + Math.random() * 100,
                    intensity: 0.5 + Math.random() * 0.5,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5
                });
            }
        }
        
        // Update spot positions and mouse trail
        function updateSpots() {
            // Move spots
            spots.forEach(spot => {
                // Update position
                spot.x += spot.vx;
                spot.y += spot.vy;
                
                // Bounce off edges
                if (spot.x < 0 || spot.x > canvas.width) {
                    spot.vx *= -1;
                }
                if (spot.y < 0 || spot.y > canvas.height) {
                    spot.vy *= -1;
                }
                
                // Add slight randomness to movement
                spot.vx += (Math.random() - 0.5) * 0.05;
                spot.vy += (Math.random() - 0.5) * 0.05;
                
                // Dampen velocity to prevent excessive movement
                spot.vx *= 0.99;
                spot.vy *= 0.99;
            });
            
            // Age trail points and remove old ones
            for (let i = mouseTrail.length - 1; i >= 0; i--) {
                mouseTrail[i].age++;
                if (mouseTrail[i].age > maxTrailLength) {
                    mouseTrail.splice(i, 1);
                }
            }
        }
        
        // Draw the heatmap
        function drawHeatmap() {
            // Start with a black background
            ctx.fillStyle = '#000033';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create an offscreen buffer for the heatmap
            const offCanvas = document.createElement('canvas');
            offCanvas.width = canvas.width;
            offCanvas.height = canvas.height;
            const offCtx = offCanvas.getContext('2d');
            
            // Clear with transparent black
            offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
            
            // Draw heat spots with radial gradients
            spots.forEach(spot => {
                const gradient = offCtx.createRadialGradient(
                    spot.x, spot.y, 0,
                    spot.x, spot.y, spot.radius
                );
                
                gradient.addColorStop(0, `rgba(255,255,255,${spot.intensity})`);
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                offCtx.fillStyle = gradient;
                offCtx.beginPath();
                offCtx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                offCtx.fill();
            });
            
            // Draw mouse trail
            mouseTrail.forEach(point => {
                const intensity = 1 - (point.age / maxTrailLength);
                const radius = 50;
                
                const gradient = offCtx.createRadialGradient(
                    point.x, point.y, 0,
                    point.x, point.y, radius
                );
                
                gradient.addColorStop(0, `rgba(255,255,255,${intensity * 0.8})`);
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                offCtx.fillStyle = gradient;
                offCtx.beginPath();
                offCtx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                offCtx.fill();
            });
            
            // Get image data from the heat map
            const heatData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
            const mainImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Apply color mapping based on heat intensity
            for (let i = 0; i < heatData.data.length; i += 4) {
                const value = heatData.data[i] / 255; // Use just the red channel for intensity
                
                if (value > 0) {
                    const color = getColor(value);
                    
                    mainImageData.data[i] = color.r;
                    mainImageData.data[i+1] = color.g;
                    mainImageData.data[i+2] = color.b;
                    mainImageData.data[i+3] = 255;
                }
            }
            
            // Put the colored data back on the main canvas
            ctx.putImageData(mainImageData, 0, 0);
            
            // Add some subtle noise for a more realistic look
            addNoise(0.02);
        }
        
        // Add noise to the canvas for a more realistic thermal look
        function addNoise(intensity) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                // Only add noise to non-black pixels
                if (data[i] > 5 || data[i+1] > 5 || data[i+2] > 5) {
                    const noise = (Math.random() - 0.5) * intensity * 255;
                    data[i] = Math.min(255, Math.max(0, data[i] + noise));
                    data[i+1] = Math.min(255, Math.max(0, data[i+1] + noise));
                    data[i+2] = Math.min(255, Math.max(0, data[i+2] + noise));
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Animation loop
        function animate() {
            updateSpots();
            drawHeatmap();
            requestAnimationFrame(animate);
        }
        
        // Mouse/touch interaction
        container.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            mouseTrail.unshift({
                x: x,
                y: y,
                age: 0
            });
            
            if (mouseTrail.length > maxTrailLength) {
                mouseTrail.pop();
            }
        });
        
        // Touch support for mobile
        container.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            mouseTrail.unshift({
                x: x,
                y: y,
                age: 0
            });
            
            if (mouseTrail.length > maxTrailLength) {
                mouseTrail.pop();
            }
        });
        
        // Initialize and start animation
        createSpots();
        animate();
    });
</script>

<style>
    .heatmap-container {
        position: relative;
        margin: 2em auto;
        border-radius: 12px;
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        height: 300px;
        width: 60ch;
        cursor: pointer;
        background-color: #000033;
    }
    
    #heatmap-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    /* Add responsive design for smaller screens */
    @media (max-width: 768px) {
        .heatmap-container {
            height: 250px;
            width: 90%;
        }
    }
</style>

</body>
</html>