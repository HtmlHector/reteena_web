<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Reteena - Building AI for Alzheimers Therapy and Diagnosis</title>
    <link href="./style.css" rel="stylesheet">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.svg">
</head>
<body>
    
<main>
    <div class="header">
        <h1>
            Reteena
        </h1>
        <a href="https://www.linkedin.com/company/reteena/" target="_blank">
            <svg height="24" viewBox="0 0 24 24" width="24" xmlns="file:///Users/yangseung-yong/Downloads/external-link.svg">
                <path d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zm-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93zM6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37z"
                      fill="currentColor"/>
            </svg>
        </a>
    </div>

    <section class="introduction">
        <p>
            We are building Low-Field MRI Resolution Image Enhancement Framework for Better Alzheimer's Diagnosis and
            the
            <a href="https://www.linkedin.com/posts/alexyang77_introducing-remembrance-by-reteena-the-activity-7332915036396433409-bNQ6?utm_source=share&utm_medium=member_desktop&rcm=ACoAAE3UIjQBZFtlI1COnxn2N_ig4-DZEnujWtM" target="_blank" class="external-link">
                <span style="text-decoration: underline;">LLM-based Memory Repository for Reminiscence Therapy</span>
                <svg xmlns="http://www.w3.org/2000/svg" height="14" viewBox="0 0 24 24" width="14" style="vertical-align: middle; margin-left: 4px;">
                    <path d="M18 13v6a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <polyline points="15 3 21 3 21 9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <line x1="10" y1="14" x2="21" y2="3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </a>
        </p>

        <p>
            Reteena shares the same pronunciation as retina, a vital part of the eye used for vision. Like the retina,
            Reteena aims to provide a new perspective on Alzheimer's.
        </p>

        <p>Founded by <a href="https://www.linkedin.com/in/alexyang77/" target="_blank">Alex</a>, <a
                href="https://www.linkedin.com/in/aarav-minocha-0828a286/" target="_blank">Aarav</a>, <a
                href="https://www.linkedin.com/in/jainish-patel-h/" target="_blank">Jainish</a>, <a
                href="https://www.linkedin.com/in/jessica-wu-817ba523b/" target="_blank">Jessica</a>, and <a
                href="https://www.linkedin.com/in/bhavya-mamnani-212a79233/" target="_blank">Bhavya</a>, with <a
                href="https://www.linkedin.com/in/sanghoo-ahn/" target="_blank">Sanghoo</a>, <a
                href="https://www.linkedin.com/in/ivanmadmv/" target="_blank">Ivan</a>, <a
                href="https://www.linkedin.com/in/olivia-jeon-6a43a52a7/" target="_blank">Olivia</a>, and <a
                href="https://www.linkedin.com/in/nathan-he-603a30255/" target="_blank">Nathan</a> later joining the
            team. </p>
    </section>

    <div id="eye-animation-container" class="eye-animation-container">
        <canvas id="eye-animation-canvas"></canvas>
    </div>

    <section class="achievements">
        <p>We have achieved multiple milestones: submission to <a class="strong__links"
                                                  href="https://solve.mit.edu/solutions/86724"
                                                  target="_blank">MIT
            SOLVE</a>, presentation at <a class="strong__links"
                          href="https://ieeexplore.ieee.org/document/10826144" target="_blank">IEEE
            BigData
            2024</a>, sponsorship
            from <a class="strong__links"
               href="https://foundershub.startups.microsoft.com/" target="_blank">Microsoft Founders Hub</a>, and
            additional
            accomplishments. </p>
        <p>
            Our team will soon launch our memory repository platform in partnership with OpenNLP labs. We continuously
            experiment with innovative concepts and new ideas! Sign up below.
        </p>

        <!-- Email input system added here -->
        <div class="email-signup">
            <form id="email-form" novalidate>
                <input type="email" id="email-input" placeholder="Enter your email">
                <button type="submit" id="email-submit">Send</button>
            </form>
            <p id="email-message" class="email-message">Please enter your email address</p>
        </div>
    </section>

    <footer>
        <div class="footer_sub">
            <p>Design Inspired from linkd.inc</p>
            <p>Copyright Â© 2025 Reteena. All rights reserved.</p>
        </div>
    </footer>
</main>

<script>
    // Hide message initially
    document.getElementById('email-message').style.display = 'none';
    
    document.getElementById('email-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const emailInput = document.getElementById('email-input');
        const email = emailInput.value;
        const emailMessage = document.getElementById('email-message');
        
        if (!email) {
            // Show error message if empty
            emailInput.style.borderColor = '#ff3b30';
            emailMessage.textContent = 'Please enter your email address';
            emailMessage.style.color = '#ff3b30';
            emailMessage.style.display = 'block';
        } else {
            // Success message
            emailMessage.textContent = 'Thank you for subscribing!';
            emailMessage.style.color = '#4CAF50';
            emailMessage.style.display = 'block';
            emailInput.style.borderColor = '#e1e1e1';
            emailInput.value = '';
            // Here you would typically send this to a server
        }
    });

    // Detailed Eye Animation
    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById('eye-animation-canvas');
        const container = document.getElementById('eye-animation-container');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to container size
        function resizeCanvas() {
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Animation variables
        const particleCount = 1000; // Optimized particle count
        let particles = [];
        let mouseX = 0;
        let mouseY = 0;
        let mouseRadius = 100;
        let frame = 0;
        let pupilSize = 0.2; // Size of pupil (normalized)
        let blinking = false;
        let blinkProgress = 0;
        let lastBlinkTime = 0;
        
        // Create particles for the eye shape
        function createEyeParticles() {
            particles = [];
            const eyePoints = createEyeShape();
            
            for (let i = 0; i < eyePoints.length; i++) {
                const point = eyePoints[i];
                const x = point.x * canvas.width;
                const y = point.y * canvas.height;
                
                particles.push({
                    x: x,
                    y: y,
                    originalX: x,
                    originalY: y,
                    size: Math.random() * 1.5 + 1,
                    color: '#ffffff', // Only white particles
                    vx: 0,
                    vy: 0,
                    zone: point.zone, // Which part of the eye (iris, pupil, sclera)
                    inPupil: point.inPupil || false
                });
            }
        }
        
        // Create eye shape points
        function createEyeShape() {
            const points = [];
            const centerX = 0.5;
            const centerY = 0.5;
            const eyeWidth = 0.35;
            const eyeHeight = 0.2;
            const irisRadius = 0.15;
            const pupilRadius = 0.05;
            
            // Create eye outline (almond shape)
            const outlinePoints = 200;
            for (let i = 0; i < outlinePoints; i++) {
                const angle = (i / outlinePoints) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * eyeWidth * Math.sin(angle * 2) * 0.9;
                const y = centerY + Math.sin(angle) * eyeHeight;
                
                points.push({
                    x: x,
                    y: y,
                    zone: 'outline'
                });
            }
            
            // Create sclera (white part of eye)
            const scleraPoints = 300;
            for (let i = 0; i < scleraPoints; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radiusMultiplier = Math.pow(Math.random(), 0.5); // Distribution to fill the shape
                const radius = (eyeWidth * 0.9 * Math.sin(angle * 2) * 0.85) * radiusMultiplier;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * (eyeHeight * 0.85) * radiusMultiplier;
                
                // Check if the point is within the eye shape
                const distance = Math.sqrt(
                    Math.pow((x - centerX) / (eyeWidth * Math.sin(angle * 2) * 0.9), 2) +
                    Math.pow((y - centerY) / eyeHeight, 2)
                );
                
                if (distance <= 0.85) {
                    points.push({
                        x: x,
                        y: y,
                        zone: 'sclera'
                    });
                }
            }
            
            // Create iris (colored part around pupil)
            const irisPoints = 250;
            for (let i = 0; i < irisPoints; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = irisRadius * Math.sqrt(Math.random());
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                points.push({
                    x: x,
                    y: y,
                    zone: 'iris'
                });
            }
            
            // Create pupil (center black part)
            const pupilPoints = 150;
            for (let i = 0; i < pupilPoints; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = pupilRadius * Math.sqrt(Math.random());
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                points.push({
                    x: x,
                    y: y,
                    zone: 'pupil',
                    inPupil: true
                });
            }
            
            // Add details like eyelashes and wrinkles
            const detailPoints = 100;
            
            // Upper eyelid wrinkle
            for (let i = 0; i < detailPoints/2; i++) {
                const t = (i / (detailPoints/2)) * Math.PI;
                const x = centerX + Math.cos(t) * eyeWidth * 0.8;
                const y = centerY - eyeHeight * 1.2 + Math.sin(t * 3) * 0.01;
                
                points.push({
                    x: x, 
                    y: y,
                    zone: 'detail'
                });
            }
            
            // Lower eyelid wrinkle
            for (let i = 0; i < detailPoints/2; i++) {
                const t = (i / (detailPoints/2)) * Math.PI;
                const x = centerX + Math.cos(t) * eyeWidth * 0.7;
                const y = centerY + eyeHeight * 1.1 + Math.sin(t * 2) * 0.01;
                
                points.push({
                    x: x, 
                    y: y,
                    zone: 'detail'
                });
            }
            
            return points;
        }
        
        // Draw a single particle
        function drawParticle(particle) {
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fillStyle = particle.color;
            ctx.fill();
        }
        
        // Blink effect
        function triggerBlink() {
            if (!blinking && Date.now() - lastBlinkTime > 4000 + Math.random() * 3000) {
                blinking = true;
                blinkProgress = 0;
                lastBlinkTime = Date.now();
            }
        }
        
        // Animation loop
        function animate() {
            // Clear canvas with semi-transparent background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            frame++;
            
            // Handle blinking animation
            if (blinking) {
                blinkProgress += 0.1;
                if (blinkProgress >= Math.PI) {
                    blinking = false;
                    blinkProgress = 0;
                }
            }
            
            // Random chance to trigger a blink
            if (Math.random() < 0.005) {
                triggerBlink();
            }
            
            // Calculate pupil movement following mouse
            let pupilOffsetX = 0;
            let pupilOffsetY = 0;
            
            if (mouseX > 0 && mouseY > 0) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxOffset = canvas.width * 0.05;
                
                pupilOffsetX = ((mouseX - centerX) / centerX) * maxOffset;
                pupilOffsetY = ((mouseY - centerY) / centerY) * maxOffset;
            }
            
            // Update and draw particles
            particles.forEach(particle => {
                // Apply mouse interaction
                const dx = mouseX - particle.x;
                const dy = mouseY - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < mouseRadius) {
                    // Push particles away from mouse
                    const force = (mouseRadius - distance) / mouseRadius;
                    const angle = Math.atan2(dy, dx);
                    particle.vx -= Math.cos(angle) * force * 1.5;
                    particle.vy -= Math.sin(angle) * force * 1.5;
                }
                
                // Apply pupil movement if this is a pupil particle
                if (particle.inPupil) {
                    particle.originalX = particle.originalX + pupilOffsetX;
                    particle.originalY = particle.originalY + pupilOffsetY;
                }
                
                // Apply blinking effect
                if (blinking) {
                    const blinkY = Math.sin(blinkProgress) * canvas.height * 0.15;
                    if (particle.originalY < canvas.height / 2) {
                        particle.vy -= blinkY * 0.1; // Move upper particles down
                    } else {
                        particle.vy += blinkY * 0.1; // Move lower particles up
                    }
                }
                
                // Return to original position
                particle.vx += (particle.originalX - particle.x) * 0.1;
                particle.vy += (particle.originalY - particle.y) * 0.1;
                
                // Apply physics
                particle.vx *= 0.9;
                particle.vy *= 0.9;
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Add slight natural movement to make it more alive
                particle.x += Math.sin(frame * 0.01 + particle.y * 0.01) * 0.1;
                
                // Draw the particle
                drawParticle(particle);
            });
            
            // Continue animation loop
            requestAnimationFrame(animate);
        }
        
        // Mouse interaction
        container.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        // Touch interaction for mobile
        container.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouseX = e.touches[0].clientX - rect.left;
            mouseY = e.touches[0].clientY - rect.top;
        });
        
        // Initialize and start animation
        createEyeParticles();
        animate();
    });
</script>

<style>
    .eye-animation-container {
        position: relative;
        margin: 2em auto;
        background-color: #000000;
        border-radius: 12px;
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        overflow: hidden;
        height: 300px;
        width: 60ch;
        cursor: pointer;
    }
    
    #eye-animation-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    /* Add responsive design for smaller screens */
    @media (max-width: 768px) {
        .eye-animation-container {
            height: 250px;
            width: 90%;
        }
    }
</style>

</body>
</html>